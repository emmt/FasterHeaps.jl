module TestingBinaryHeaps

using Test

using Base: Ordering, ForwardOrdering, ReverseOrdering, Forward, Reverse, lt

using QuickHeaps
using QuickHeaps:
    AbstractBinaryHeap,
    FastForwardOrdering, FastForward, FastReverse,
    FastMin, FastMax, SafeMin, SafeMax,
    isheap, heapify, heapify!,
    ordering, nodes

orientation(::Any) = 0
orientation(h::AbstractBinaryHeap) = orientation(typeof(h))
orientation(::Type{<:AbstractBinaryHeap{T,O}}) where {T,O} = orientation(O)
orientation(o::Ordering) = orientation(typeof(o))
orientation(::Type{<:Union{ForwardOrdering,FastForwardOrdering}}) = +1
orientation(::Type{<:ReverseOrdering{O}}) where {O} = -orientation(O)

is_min_ordering(x) = orientation(x) > 0
is_max_ordering(x) = orientation(x) < 0

function is_sorted(o::Base.Ordering, x::AbstractVector)
    flag = false
    for i in 2:length(x)
        flag |= lt(o, x[i], x[i-1])
    end
    return !flag
end

# Non-optimized version of `maximum`.
function get_maximum(A::AbstractArray)
    vmax = typemin(eltype(A))
    @inbounds for i in eachindex(A)
        vmax = max(A[i], vmax)
    end
    return vmax
end

# Non-optimized version of `minimum`.
function get_minimum(A::AbstractArray)
    vmin = typemax(eltype(A))
    @inbounds for i in eachindex(A)
        vmin = min(A[i], vmin)
    end
    return vmin
end

#=
get_maximum(A::AbstractArray) = maximum(A)
get_minimum(A::AbstractArray) = minimum(A)
=#

other_type(::Type{Float64}) = Float32
other_type(::Type{Float32}) = Float64
other_type(::Type{Int16}) = Int32
other_type(::Type{Int32}) = Int16
other_type(::Type{Int64}) = Int32
other_type(::Type{UInt16}) = UInt32
other_type(::Type{UInt32}) = UInt16
other_type(::Type{UInt64}) = UInt32

# A1 and A2 are two arrays such that view(A,1:i) is not a heap in any ordering
# for A = A1 or A2 and i â‰¥ 3. These arrays where randomly generated by
# something like:
#     A1 = rand(1:15, 16)
#     A2 = map(x->round(Int,100*x)/10, rand(Float64, 11))
# with some manual re-ordering of the 3 first entries to ensure that the
# non-heap property holds.
const A1 = [7, 12, 5, 13, 6, 14, 12, 1, 10, 6, 9, 4, 10, 7, 12, 14];
const A2 = [3.0, 6.4, 1.1, 9.2, 1.2, 8.2, 1.3, 7.9, 9.1, 2.3, 8.2];

@testset "Arrays as binary heaps ($id)" for (id, A, dir) in (
    ("min-heap", [1, 4, 2, 6, 5, 3, 8, 7, 11, 13, 10, 14, 9, 12], +1),
    ("max-heap", [14, 11, 13, 9, 10, 12, 7, 8, 4, 2, 5, 1, 6, 3], -1),
    ("not heap", [13, 1, 14, 8, 10, 9, 7, 2, 5, 4, 12, 3, 6, 11],  0))
    n = length(A)
    flag = (dir > 0)
    success = true
    @test flag == isheap(A)
    for np in 3:n # last elements can be discarded
        success &= (flag == isheap(A, np))
    end
    @test success
    for o in (Forward, FastForward, Reverse, FastReverse)
        flag = (dir*orientation(o) > 0)
        @test flag == isheap(A, o)
        @test flag == isheap(o, A)
        @test flag == isheap(A, n, o)
        @test flag == isheap(A, o, Int16(n))
        success = true
        for np in 3:n # last elements can be discarded
            success &= (flag == isheap(o, A, np))
        end
        @test success
    end
    if dir == 0
        # A is not a heap in any order.
        B = heapify(A)
        @test isheap(B)
        @test !isheap(B, Reverse)
        B = heapify(A, Reverse, Int16(n))
        @test !isheap(B)
        @test isheap(B, Reverse)
        C = copy(A)
        B = heapify!(C)
        @test B === C
        @test isheap(B)
        B = heapify!(C, Reverse, Int16(n))
        @test B === C
        @test isheap(B, Reverse)
    end
end

@testset "Binary heaps $B{$T}($o)" for B in (BinaryHeap, FastBinaryHeap),
    T in (Float32, Int16), o in (nothing, SafeMin, SafeMax, FastMin, FastMax)
    let h = (o === nothing ? B{T}() : B{T}(o))
        @test eltype(h) == T
        @test IndexStyle(h) == IndexLinear()
        @test length(h) == 0
        @test size(h) == (length(h),)
        @test isempty(h) == (length(h) == 0)
        @test isheap(h) && isheap(h; check=true)
        @test_throws ArgumentError peek(h)
        @test_throws ArgumentError pop!(h)
        if o === nothing
            @test ordering(h) === (B <: FastBinaryHeap ? FastMin : SafeMin)
            @test isheap(h) && isheap(h; check=true)
        else
            @test ordering(h) === o
            @test isheap(h) && isheap(h; check=true) && isheap(h; check=false)
        end
    end
    for A in (A1, A2)
        n = length(A)
        T = eltype(A)
        S = other_type(T)
        h = (o === nothing ? B{T}(copy(A)) : B{T}(o, copy(A)))
        @test eltype(h) === T
        @test IndexStyle(h) == IndexLinear()
        @test length(h) == length(A)
        @test size(h) == (length(h),)
        @test isempty(h) == (length(h) == 0)
        @test isheap(h) && isheap(h; check=true)
        if o !== nothing
            @test ordering(h) === o
            hp = B{T}(copy(A), o)
            @test typeof(hp) === typeof(h)
            @test length(hp) === length(h)
            @test ordering(hp) === ordering(h)
            @test nodes(hp) == nodes(h)
        end
        empty!(h)
        @test isempty(h)
        @test isheap(h) && isheap(h; check=true)
        for i in 1:n
            push!(h, S(A[i]))
            @test isheap(h) && isheap(h; check=true)
            @test !isempty(h)
            @test length(h) == i
            v1 = (is_min_ordering(h) ? get_minimum(h) : get_maximum(h))
            @test peek(h) === v1
            @test first(h) === v1
        end
        vmax = get_maximum(h)
        for i in 1:n
            h[i] = S(vmax + 1 - h[i])
            @test isheap(h) && isheap(h; check=true)
            @test length(h) == n
            v1 = (is_min_ordering(h) ? get_minimum(h) : get_maximum(h))
            @test peek(h) === v1
            @test first(h) === v1
        end
        x = eltype(h)[]
        while !isempty(h)
            push!(x, pop!(h))
        end
        @test length(x) == n
        @test is_sorted(ordering(h), x)
        push!(h, x...)
        @test length(h) == n
        @test isheap(h) && isheap(h; check=true)
    end
end

end # module
